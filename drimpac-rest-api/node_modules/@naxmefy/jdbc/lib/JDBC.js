"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require("debug");
const lodash_1 = require("lodash");
const Connection_1 = require("./Connection");
const Java_1 = require("./Java");
class JDBC {
    constructor(config) {
        this.debug = debug('@naxmefy/jdbc');
        this.config = config;
        this.validateConfig();
        this.debug('setup jdbc instance for', this.config.className);
        this.registerDriver();
    }
    getConnection(connectIfClosed) {
        if (!this.connection) {
            return this.connection = this.newConnection();
        }
        return this.connection.then((connection) => {
            if (connection.isClosed() && connectIfClosed) {
                return this.connection = this.newConnection();
            }
            return connection;
        });
    }
    createStatement(connectIfClosed) {
        return this.getConnection(connectIfClosed)
            .then((connection) => connection.createStatement());
    }
    validateConfig() {
        if (lodash_1.isEmpty(this.config.className)) {
            throw new Error('Missing driver class');
        }
    }
    classForName() {
        this.debug('generate new java instance for driver', this.config.className);
        return Java_1.Java.getInstance().java.newInstanceSync(this.config.className);
    }
    registerDriver() {
        const driver = this.classForName();
        this.debug('register jdbc driver', this.config.className);
        return Java_1.Java.getInstance().java.callStaticMethodSync('java.sql.DriverManager', 'registerDriver', driver);
    }
    newConnection() {
        return Java_1.Java.getInstance().java.callStaticMethodAsync('java.sql.DriverManager', 'getConnection', this.config.url, this.config.username || null, this.config.password || null)
            .then((connection) => new Connection_1.Connection(connection));
    }
}
exports.JDBC = JDBC;
//# sourceMappingURL=JDBC.js.map